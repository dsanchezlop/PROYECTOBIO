{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { ref } from 'vue';\nexport default {\n  __name: 'SVGMap',\n  setup(__props, {\n    expose\n  }) {\n    expose();\n    const hoverValue = ref(\"Mouse your mouse\");\n    const selectedStates = ref([]);\n    const zoomLevel = ref(1);\n    const dragInfo = ref(null);\n    const svgContent = '';\n    const worldPaths = [];\n    function clearSelection() {\n      // Vaciar el array de países seleccionados\n      selectedStates.value.splice(0);\n\n      // Deseleccionar todos los elementos del DOM que tengan la clase \"selectedPath\"\n      const selectedPaths = document.querySelectorAll(\".selectedPath\");\n      selectedPaths.forEach(element => {\n        element.classList.remove(\"selectedPath\");\n      });\n    }\n\n    //Adds to the path array a\n    function setSelectedPath(hvalue) {\n      if (hvalue.target.attributes[\"title\"]) {\n        if (hvalue != null && hvalue.target != null) {\n          // Verificar si el valor ya está seleccionado\n          const title = hvalue.target.attributes[\"title\"].value;\n          const id = hvalue.target.attributes[\"id\"].value;\n          const isSelected = selectedStates.value.some(item => item.id === id);\n          if (isSelected) {\n            // Si el valor ya está seleccionado, eliminarlo del array y eliminar la clase\n            selectedStates.value = selectedStates.value.filter(item => item.id !== id);\n            hvalue.target.classList.remove(\"selectedPath\");\n          } else {\n            // Si el valor no está seleccionado, agregarlo al array y agregar la clase\n            selectedStates.value.push({\n              id,\n              title\n            });\n            hvalue.target.classList.add(\"selectedPath\");\n          }\n        }\n      }\n    }\n    function changeHoverValue(hvalue) {\n      if (hvalue != null && hvalue.target != null) {\n        let title = hvalue.target.attributes[\"title\"];\n        if (title != null) {\n          hoverValue.value = title.value;\n        }\n      }\n    }\n    function zoomIn() {\n      zoomLevel.value /= 0.90;\n    }\n    function zoomOut() {\n      if (zoomLevel.value <= 0.6) {} else {\n        zoomLevel.value *= 0.90;\n      }\n    }\n    function getMousePosition(evt) {\n      var CTM = svg.getScreenCTM();\n      return {\n        x: (evt.clientX - CTM.e) / CTM.a,\n        y: (evt.clientY - CTM.f) / CTM.d\n      };\n    }\n\n    // function startDrag(evt) {\n    //   // store the initial mouse position and map position\n    //   dragInfo.value = {\n    //     x: evt.clientX,\n    //     y: evt.clientY,\n    //     mapX: parseFloat($refs.svgMap.style.left) || 0,\n    //     mapY: parseFloat($refs.svgMap.style.top) || 0,\n    //   };\n    //   // set cursor to grabbing\n    //   evt.target.style.cursor = 'grabbing';\n    // }\n\n    // function drag(evt) {\n    //   if (dragInfo.value) {\n    //     // calculate the offset between the current mouse position and the initial mouse position\n    //     const dx = evt.clientX - dragInfo.value.x;\n    //     const dy = evt.clientY - dragInfo.value.y;\n    //     // set the new map position based on the offset\n    //     $refs.svgMap.style.left = `${dragInfo.value.mapX + dx}px`;\n    //     $refs.svgMap.style.top = `${dragInfo.value.mapY + dy}px`;\n    //   }\n    // }\n\n    // function endDrag(evt) {\n    //   dragInfo.value = null;\n    //   evt.target.style.cursor = 'grab';\n    // }\n\n    function mounted() {\n      axios.get('/assets/world.svg').then(response => {\n        this.svgContent = response.data;\n      }).catch(error => {\n        console.log(error);\n      });\n    }\n    function onExtractPaths() {\n      axios.post('/svg-paths', {\n        svgContent: this.svgContent\n      }).then(response => {\n        const paths = response.data.paths;\n        this.worldPaths = paths;\n        this.drawWorldMap();\n      }).catch(error => {\n        console.log(error);\n      });\n    }\n    function drawWorldMap() {\n      const svg = document.getElementById('my-svg');\n\n      // Limpiar el contenido del SVG antes de agregar los nuevos paths\n      while (svg.lastChild) {\n        svg.removeChild(svg.lastChild);\n      }\n\n      // Iterar sobre los paths obtenidos por la API y agregarlos al SVG\n      for (let i = 0; i < this.worldPaths.length; i++) {\n        const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute(\"d\", this.worldPaths[i].d);\n        path.setAttribute(\"id\", this.worldPaths[i].id);\n        path.setAttribute(\"title\", this.worldPaths[i].title);\n        svg.appendChild(path);\n      }\n    }\n    // Agregamos un evento de carga para asegurarnos de que el mapa se cargue completamente antes de dibujarlo\n    window.addEventListener('load', function () {\n      // Hacemos una llamada a la API de Mapbox\n      $.getJSON('https://api.mapbox.com/styles/v1/mapbox/streets-v11?access_token=YOUR_ACCESS_TOKEN', function (data) {\n        // Obtenemos el objeto \"layers\" de la respuesta de la API\n        var layers = data.layers;\n\n        // Buscamos la capa que contiene los datos del mapa\n        var source = layers.find(function (layer) {\n          return layer.type === 'vector' && layer.id === 'mapbox-streets-v8';\n        }).source;\n\n        // Configuramos el objeto de opciones de la capa de mapa\n        var options = {\n          container: 'map',\n          // ID del elemento en el que se dibujará el mapa\n          style: 'mapbox://styles/mapbox/streets-v11',\n          // ID del estilo de mapa\n          zoom: 10,\n          // Nivel de zoom inicial\n          center: [-75.1652, 39.9526],\n          // Coordenadas iniciales\n          minZoom: 3,\n          // Zoom mínimo permitido\n          maxZoom: 18,\n          // Zoom máximo permitido\n          hash: true,\n          // Habilitar la actualización del hash de la URL en el cambio de vista\n          interactive: true // Permitir la interacción con el mapa\n        };\n\n        // Creamos un objeto de mapa usando las opciones configuradas anteriormente\n        var map = new mapboxgl.Map(options);\n\n        // Agregamos la capa de mapa al objeto de mapa\n        map.on('load', function () {\n          map.addSource(source, {\n            type: 'vector',\n            url: 'mapbox://mapbox.mapbox-streets-v8'\n          });\n\n          // Obtenemos los datos de la capa de mapa usando la biblioteca D3\n          d3.json('https://api.mapbox.com/v4/mapbox.mapbox-streets-v8.json?access_token=YOUR_ACCESS_TOKEN', function (error, data) {\n            if (error) throw error;\n\n            // Creamos un objeto de capa de mapa usando los datos de la capa de mapa\n            var layer = {\n              'id': 'mapbox-streets-v8',\n              'type': 'line',\n              'source': source,\n              'source-layer': 'road',\n              'paint': {\n                'line-color': '#627BC1',\n                'line-width': 2\n              }\n            };\n\n            // Agregamos la capa de mapa al objeto de mapa\n            map.addLayer(layer);\n          });\n        });\n      });\n    });\n    const __returned__ = {\n      hoverValue,\n      selectedStates,\n      zoomLevel,\n      dragInfo,\n      svgContent,\n      worldPaths,\n      clearSelection,\n      setSelectedPath,\n      changeHoverValue,\n      zoomIn,\n      zoomOut,\n      getMousePosition,\n      mounted,\n      onExtractPaths,\n      drawWorldMap,\n      ref\n    };\n    Object.defineProperty(__returned__, '__isScriptSetup', {\n      enumerable: false,\n      value: true\n    });\n    return __returned__;\n  }\n};","map":{"version":3,"names":["ref","hoverValue","selectedStates","zoomLevel","dragInfo","svgContent","worldPaths","clearSelection","value","splice","selectedPaths","document","querySelectorAll","forEach","element","classList","remove","setSelectedPath","hvalue","target","attributes","title","id","isSelected","some","item","filter","push","add","changeHoverValue","zoomIn","zoomOut","getMousePosition","evt","CTM","svg","getScreenCTM","x","clientX","e","a","y","clientY","f","d","mounted","axios","get","then","response","data","catch","error","console","log","onExtractPaths","post","paths","drawWorldMap","getElementById","lastChild","removeChild","i","length","path","createElementNS","setAttribute","appendChild","window","addEventListener","$","getJSON","layers","source","find","layer","type","options","container","style","zoom","center","minZoom","maxZoom","hash","interactive","map","mapboxgl","Map","on","addSource","url","d3","json","addLayer"],"sources":["/home/lasmas/GitHub/PROYECTOBIO/my-svg-map/src/components/SVGMap.vue"],"sourcesContent":["<template>\n   <button class=\"button-zoom\" @click=\"zoomIn\">+</button>\n   <button class=\"button-zoom\" @click=\"zoomOut\">-</button>\n   <br>\n   <button class=\"button-container\" @click=\"clearSelection\"> Clear Selection </button>\n\n   <div>\n      <h2> Selected Countries :</h2>\n      <div style=\"display:inline\">\n         <h4 style=\"display:inline; margin:10px;\" v-for=\"state in selectedStates\" :key=\"state.id\"> {{ state.id }} :\n            {{ state.title }} </h4>\n      </div>\n      <div style=\"display:flex; text-align: center; align-items: center;\">\n         <h2>Hovered Country:</h2>\n         <h3 style=\"color: black\"> {{ hoverValue }} </h3>\n      </div>\n   </div>\n   <div class=\"map-container\" id=\"my-svg\">\n      <!-- intentar que los path sean devuelto por la API -->\n      <!-- <svg xmlns:mapsvg=\"http://mapsvg.com\" version=\"1.1\" id=\"svg2\" ref=\"svgMap\"\n         mapsvg:geoViewBox=\"68.184010 37.084109 97.418146 6.753659\" width=\"1009.6727\" height=\"665.96301\"\n         :style=\"{ transform: `scale(${zoomLevel})` }\" @mouseover=\"changeHoverValue\" @click=\"setSelectedPath\"\n        >\n         \n      </svg> -->\n\n\n   </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue';\n\nconst hoverValue = ref(\"Mouse your mouse\");\nconst selectedStates = ref([]);\nconst zoomLevel = ref(1);\nconst dragInfo = ref(null);\nconst svgContent = '';\nconst worldPaths = [];\n\nfunction clearSelection() {\n   // Vaciar el array de países seleccionados\n   selectedStates.value.splice(0);\n\n   // Deseleccionar todos los elementos del DOM que tengan la clase \"selectedPath\"\n   const selectedPaths = document.querySelectorAll(\".selectedPath\");\n   selectedPaths.forEach(element => {\n      element.classList.remove(\"selectedPath\");\n   });\n}\n\n//Adds to the path array a\nfunction setSelectedPath(hvalue) {\n   if (hvalue.target.attributes[\"title\"]) {\n      if (hvalue != null && hvalue.target != null) {\n         // Verificar si el valor ya está seleccionado\n         const title = hvalue.target.attributes[\"title\"].value;\n         const id = hvalue.target.attributes[\"id\"].value;\n         const isSelected = selectedStates.value.some(item => item.id === id);\n\n         if (isSelected) {\n            // Si el valor ya está seleccionado, eliminarlo del array y eliminar la clase\n            selectedStates.value = selectedStates.value.filter(item => item.id !== id);\n            hvalue.target.classList.remove(\"selectedPath\");\n         } else {\n            // Si el valor no está seleccionado, agregarlo al array y agregar la clase\n            selectedStates.value.push({ id, title });\n            hvalue.target.classList.add(\"selectedPath\");\n         }\n      }\n   }\n}\n\n\nfunction changeHoverValue(hvalue) {\n   if (hvalue != null && hvalue.target != null) {\n      let title = hvalue.target.attributes[\"title\"];\n      if (title != null) {\n         hoverValue.value = title.value;\n      }\n   }\n}\n\nfunction zoomIn() {\n   zoomLevel.value /= 0.90;\n}\n\nfunction zoomOut() {\n   if (zoomLevel.value <= 0.6) {\n\n   }\n   else {\n      zoomLevel.value *= 0.90;\n   }\n}\n\nfunction getMousePosition(evt) {\n   var CTM = svg.getScreenCTM();\n   return {\n      x: (evt.clientX - CTM.e) / CTM.a,\n      y: (evt.clientY - CTM.f) / CTM.d\n   };\n}\n\n// function startDrag(evt) {\n//   // store the initial mouse position and map position\n//   dragInfo.value = {\n//     x: evt.clientX,\n//     y: evt.clientY,\n//     mapX: parseFloat($refs.svgMap.style.left) || 0,\n//     mapY: parseFloat($refs.svgMap.style.top) || 0,\n//   };\n//   // set cursor to grabbing\n//   evt.target.style.cursor = 'grabbing';\n// }\n\n// function drag(evt) {\n//   if (dragInfo.value) {\n//     // calculate the offset between the current mouse position and the initial mouse position\n//     const dx = evt.clientX - dragInfo.value.x;\n//     const dy = evt.clientY - dragInfo.value.y;\n//     // set the new map position based on the offset\n//     $refs.svgMap.style.left = `${dragInfo.value.mapX + dx}px`;\n//     $refs.svgMap.style.top = `${dragInfo.value.mapY + dy}px`;\n//   }\n// }\n\n// function endDrag(evt) {\n//   dragInfo.value = null;\n//   evt.target.style.cursor = 'grab';\n// }\n\nfunction mounted() {\n  axios.get('/assets/world.svg')\n    .then(response => {\n      this.svgContent = response.data;\n    })\n    .catch(error => {\n      console.log(error);\n    });\n}\nfunction onExtractPaths() {\n  axios.post('/svg-paths', { svgContent: this.svgContent })\n    .then(response => {\n      const paths = response.data.paths;\n      this.worldPaths = paths;\n      this.drawWorldMap();\n    })\n    .catch(error => {\n      console.log(error);\n    });\n}\n\nfunction drawWorldMap() {\n  const svg = document.getElementById('my-svg');\n\n  // Limpiar el contenido del SVG antes de agregar los nuevos paths\n  while (svg.lastChild) {\n    svg.removeChild(svg.lastChild);\n  }\n\n  // Iterar sobre los paths obtenidos por la API y agregarlos al SVG\n  for (let i = 0; i < this.worldPaths.length; i++) {\n    const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    path.setAttribute(\"d\", this.worldPaths[i].d);\n    path.setAttribute(\"id\", this.worldPaths[i].id);\n    path.setAttribute(\"title\", this.worldPaths[i].title);\n    svg.appendChild(path);\n  }\n}\n// Agregamos un evento de carga para asegurarnos de que el mapa se cargue completamente antes de dibujarlo\nwindow.addEventListener('load', function() {\n  // Hacemos una llamada a la API de Mapbox\n  $.getJSON('https://api.mapbox.com/styles/v1/mapbox/streets-v11?access_token=YOUR_ACCESS_TOKEN', function(data) {\n    // Obtenemos el objeto \"layers\" de la respuesta de la API\n    var layers = data.layers;\n    \n    // Buscamos la capa que contiene los datos del mapa\n    var source = layers.find(function(layer) {\n      return layer.type === 'vector' && layer.id === 'mapbox-streets-v8';\n    }).source;\n\n    // Configuramos el objeto de opciones de la capa de mapa\n    var options = {\n      container: 'map', // ID del elemento en el que se dibujará el mapa\n      style: 'mapbox://styles/mapbox/streets-v11', // ID del estilo de mapa\n      zoom: 10, // Nivel de zoom inicial\n      center: [-75.1652, 39.9526], // Coordenadas iniciales\n      minZoom: 3, // Zoom mínimo permitido\n      maxZoom: 18, // Zoom máximo permitido\n      hash: true, // Habilitar la actualización del hash de la URL en el cambio de vista\n      interactive: true // Permitir la interacción con el mapa\n    };\n\n    // Creamos un objeto de mapa usando las opciones configuradas anteriormente\n    var map = new mapboxgl.Map(options);\n\n    // Agregamos la capa de mapa al objeto de mapa\n    map.on('load', function() {\n      map.addSource(source, {\n        type: 'vector',\n        url: 'mapbox://mapbox.mapbox-streets-v8'\n      });\n\n      // Obtenemos los datos de la capa de mapa usando la biblioteca D3\n      d3.json('https://api.mapbox.com/v4/mapbox.mapbox-streets-v8.json?access_token=YOUR_ACCESS_TOKEN', function(error, data) {\n        if (error) throw error;\n\n        // Creamos un objeto de capa de mapa usando los datos de la capa de mapa\n        var layer = {\n          'id': 'mapbox-streets-v8',\n          'type': 'line',\n          'source': source,\n          'source-layer': 'road',\n          'paint': {\n            'line-color': '#627BC1',\n            'line-width': 2\n          }\n        };\n\n        // Agregamos la capa de mapa al objeto de mapa\n        map.addLayer(layer);\n      });\n    });\n  });\n});\n\n</script>\n\n<style scoped>\n@keyframes slowchange {\n   to {\n      fill: indianred;\n   }\n}\n\n@keyframes hoverChange {\n   to {\n      fill: purple;\n   }\n}\n\npath {\n   fill: black;\n}\n\n.selectedPath {\n   animation-name: slowchange;\n   animation-duration: 1.5s;\n   animation-fill-mode: forwards;\n}\n\npath:hover {\n   animation-name: hoverChange;\n   animation-duration: 1s;\n   animation-fill-mode: forwards;\n}\n\n.logo {\n   height: 6em;\n   padding: 1.5em;\n   will-change: filter;\n}\n\n.logo:hover {\n   filter: drop-shadow(0 0 2em #646cffaa);\n}\n\n.logo.vue:hover {\n   filter: drop-shadow(0 0 2em #42b883aa);\n}\n\n.map-container {\n   width: 100vw;\n   /* ancho al 100% de la ventana */\n   /* height: 100vh; altura al 100% de la ventana */\n   display: flex;\n   justify-content: center;\n   /* centro horizontal */\n   align-items: center;\n   /* centro vertical */\n}\n\n.button-container {\n   position: relative;\n   z-index: 1;\n   margin-right: auto;\n   width: fit-content;\n   height: fit-content;\n}\n\n.button-zoom {\n   position: relative;\n   z-index: 1;\n   margin-right: auto;\n   width: 2%;\n   height: 2%;\n}\n\n.draggeable {\n   cursor: move;\n}\n</style>\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}